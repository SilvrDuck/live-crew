"""Decorator support for simplified handler creation."""

import functools
from typing import Any, Callable, Optional, Union

from live_crew.core.models import Action, Event


def event_handler(
    event_types: Union[str, list[str], None] = None,
    crew_id: Optional[str] = None,
):
    """Decorator to create event handlers with minimal boilerplate.

    This decorator converts a simple function into a full EventHandler
    protocol implementation, reducing the code needed for basic handlers.

    Args:
        event_types: Event type(s) this handler should process.
                    Can be a string, list of strings, or None for all events.
        crew_id: Optional crew identifier. If None, uses function name.

    Examples:
        Basic handler:
        >>> @event_handler("user_signup")
        ... def greet_user(event):
        ...     return Action.create("greeting", f"Welcome {event.payload['name']}!")

        Multiple event types:
        >>> @event_handler(["user_signup", "user_login"])
        ... def track_user_activity(event):
        ...     return Action.create("activity_logged", {"event": event.kind})

        Handler for all events:
        >>> @event_handler()
        ... def log_everything(event):
        ...     return Action.create("logged", {"original_event": event.kind})

    Returns:
        EventHandler protocol implementation that can be registered with Orchestrator
    """

    def decorator(
        func: Callable[[Event[Any]], Union[Action[Any], list[Action[Any]], dict]],
    ):
        class DecoratedEventHandler:
            """Generated EventHandler implementation."""

            def __init__(self):
                self._crew_id = crew_id or func.__name__
                self._event_types = []

                if event_types is not None:
                    if isinstance(event_types, str):
                        self._event_types = [event_types]
                    else:
                        self._event_types = list(event_types)

            @property
            def crew_id(self) -> str:
                """Get the crew identifier."""
                return self._crew_id

            async def handle_event(
                self, event: Event[Any], context: dict[str, Any]
            ) -> list[Action[Any]]:
                """Handle an event using the decorated function.

                Args:
                    event: The event to process
                    context: Current context snapshot

                Returns:
                    List of actions generated by the handler
                """
                # Call the original function
                result = func(event)

                # Handle different return types
                if result is None:
                    return []
                elif isinstance(result, Action):
                    return [result]
                elif isinstance(result, list):
                    return result
                elif isinstance(result, dict):
                    # Convert dict to Action for convenience
                    return [
                        Action[dict](
                            ts=event.ts,
                            kind=result.get("kind", f"processed_{event.kind}"),
                            stream_id=event.stream_id,
                            payload=result.get("payload", result),
                            ttl_ms=result.get("ttl_ms", 5000),
                        )
                    ]
                else:
                    # Treat other types as payload
                    return [
                        Action[Any](
                            ts=event.ts,
                            kind=f"processed_{event.kind}",
                            stream_id=event.stream_id,
                            payload=result,
                            ttl_ms=5000,
                        )
                    ]

            def get_event_types(self) -> list[str]:
                """Get the event types this handler processes."""
                return self._event_types

        # Create and return the handler instance
        handler = DecoratedEventHandler()

        # Store original function for debugging/introspection
        handler._original_function = func
        handler._event_types_param = event_types

        # Use functools.update_wrapper to preserve function metadata
        functools.update_wrapper(handler, func)

        return handler

    return decorator


class HandlerBuilder:
    """Builder for creating handlers programmatically.

    This provides an alternative to the decorator syntax for cases
    where dynamic handler creation is needed.
    """

    def __init__(self, crew_id: str):
        self.crew_id = crew_id
        self._event_types: list[str] = []
        self._handler_func: Optional[Callable] = None

    def for_events(self, event_types: Union[str, list[str]]) -> "HandlerBuilder":
        """Specify which event types this handler should process."""
        if isinstance(event_types, str):
            self._event_types = [event_types]
        else:
            self._event_types = list(event_types)
        return self

    def with_handler(self, func: Callable[[Event[Any]], Any]) -> "HandlerBuilder":
        """Specify the handler function."""
        self._handler_func = func
        return self

    def build(self):
        """Build the final EventHandler implementation."""
        if self._handler_func is None:
            raise ValueError("Handler function not specified. Use with_handler().")

        # Use the decorator to create the handler
        decorator = event_handler(self._event_types, self.crew_id)
        return decorator(self._handler_func)
